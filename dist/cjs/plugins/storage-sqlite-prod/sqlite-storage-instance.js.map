{"version":3,"file":"sqlite-storage-instance.js","names":["_index","require","_rxjs","_sqliteHelpers","_rxQueryHelper","_rxError","instanceId","RxStorageInstanceSQLite","exports","storage","databaseName","collectionName","schema","internals","options","settings","tableName","devMode","changes$","Subject","openWriteCount$","BehaviorSubject","sqliteBasics","primaryPath","getPrimaryFieldOfPrimaryKey","primaryKey","_proto","prototype","run","db","queryWithParams","ensureParamsCountIsCorrect","all","convertRxQueryToSQL","query","sqlParts","whereClauses","params","orderBy","selector","selectorResult","convertSelectorToSQL","canConvert","canUseSql","push","clauses","sort","sortResult","convertSortToSQL","length","join","limit","undefined","skip","sql","error","field","value","Object","entries","$eq","metaResult","convertMetaFieldToSQL","orResult","convertOrToSQL","clause","andResult","convertAndToSQL","fieldResult","convertFieldToSQL","metaValue","lwt","op","opValue","orConditions","orClauses","condition","cleanCondition","_deleted","conditionResult","andConditions","andClauses","isPrimaryKey","jsonPath","hasOwnProperty","$exists","sqlValue","convertValueForSQL","$ne","inValues","$in","Array","isArray","placeholders","map","sqlValues","v","ninValues","$nin","getJsonComparisonClause","sortItem","keys","direction","operator","isNumeric","bulkWrite","documentWrites","context","next","getValue","database","databasePromise","ret","writePromises","categorized","sqliteTransaction","closed","Error","idsToQuery","row","document","docsInDb","Map","result","method","data","forEach","docSQLResult","doc","JSON","parse","getDataFromResultRow","id","set","categorizeBulkWriteRows","errors","bulkInsertDocs","insertQuery","getSQLiteInsertSQL","bulkUpdateDocs","updateQuery","getSQLiteUpdateSQL","Promise","eventBulk","events","lastState","ensureNotFalsy","newestRow","checkpoint","_meta","originalPreparedQuery","sqlQuery","console","log","stringify","subResult","docData","documents","Infinity","skipPlusLimit","queryMatcher","getQueryMatcher","sortComparator","getSortComparator","slice","count","countSql","replace","cleanCountSql","countParams","pop","countValue","mode","results","findDocumentsById","ids","withDeleted","i","resultRow","changeStream","asObservable","cleanup","minimumDeletedTime","promiseWait","minTimestamp","Date","getTime","getAttachmentData","_documentId","_attachmentId","newRxError","remove","promises","close","queue","TX_QUEUE_BY_DATABASE","get","firstValueFrom","pipe","filter","resolve","catch","complete","closeDatabaseConnection","createSQLiteTrialStorageInstance","version","attachments","useDatabaseName","databaseNamePrefix","getDatabaseConnection","then","tableQuery","indexes","indexQuery","indexCreation","instance","addRxStorageMultiInstanceSupport","RX_STORAGE_NAME_SQLITE"],"sources":["../../../../src/plugins/storage-sqlite-prod/sqlite-storage-instance.ts"],"sourcesContent":["import {\n    RxJsonSchema,\n    RxStorageInstanceCreationParams,\n    RxStorageInstance,\n    getPrimaryFieldOfPrimaryKey,\n    EventBulk,\n    RxStorageChangeEvent,\n    RxDocumentData,\n    BulkWriteRow,\n    RxStorageBulkWriteResponse,\n    RxStorageQueryResult,\n    categorizeBulkWriteRows,\n    ensureNotFalsy,\n    StringKeys,\n    addRxStorageMultiInstanceSupport,\n    RxStorageDefaultCheckpoint,\n    CategorizeBulkWriteRowsOutput,\n    RxStorageCountResult,\n    promiseWait,\n    getQueryMatcher,\n    PreparedQuery,\n} from '../../index.ts';\nimport {\n    BehaviorSubject,\n    Observable,\n    Subject,\n    filter,\n    firstValueFrom,\n} from 'rxjs';\nimport type { RxStorageSQLiteProd } from './index.ts';\nimport {\n    closeDatabaseConnection,\n    ensureParamsCountIsCorrect,\n    getDatabaseConnection,\n    getSQLiteUpdateSQL,\n    RX_STORAGE_NAME_SQLITE,\n    sqliteTransaction,\n    getDataFromResultRow,\n    getSQLiteInsertSQL,\n    TX_QUEUE_BY_DATABASE,\n} from './sqlite-helpers.ts';\nimport type {\n    SQLiteBasics,\n    SQLiteInstanceCreationOptions,\n    SQLiteInternals,\n    SQLiteQueryWithParams,\n    SQLiteStorageSettings,\n} from './sqlite-types.ts';\nimport { getSortComparator } from '../../rx-query-helper.ts';\nimport { newRxError } from '../../rx-error.ts';\n\nlet instanceId = 0;\nexport class RxStorageInstanceSQLite<RxDocType>\n    implements\n        RxStorageInstance<\n            RxDocType,\n            SQLiteInternals,\n            SQLiteInstanceCreationOptions,\n            RxStorageDefaultCheckpoint\n        >\n{\n    public readonly primaryPath: StringKeys<RxDocType>;\n    private changes$: Subject<\n        EventBulk<\n            RxStorageChangeEvent<RxDocumentData<RxDocType>>,\n            RxStorageDefaultCheckpoint\n        >\n    > = new Subject();\n    public readonly instanceId = instanceId++;\n    public closed?: Promise<void>;\n\n    public sqliteBasics: SQLiteBasics<any>;\n\n    public readonly openWriteCount$ = new BehaviorSubject(0);\n\n    constructor(\n        public readonly storage: RxStorageSQLiteProd,\n        public readonly databaseName: string,\n        public readonly collectionName: string,\n        public readonly schema: Readonly<\n            RxJsonSchema<RxDocumentData<RxDocType>>\n        >,\n        public readonly internals: SQLiteInternals,\n        public readonly options: Readonly<SQLiteInstanceCreationOptions>,\n        public readonly settings: SQLiteStorageSettings,\n        public readonly tableName: string,\n        public readonly devMode: boolean\n    ) {\n        this.sqliteBasics = storage.settings.sqliteBasics;\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(\n            this.schema.primaryKey\n        ) as any;\n    }\n\n    run(db: any, queryWithParams: SQLiteQueryWithParams) {\n        if (this.devMode) {\n            ensureParamsCountIsCorrect(queryWithParams);\n        }\n        return this.sqliteBasics.run(db, queryWithParams);\n    }\n    all(db: any, queryWithParams: SQLiteQueryWithParams) {\n        if (this.devMode) {\n            ensureParamsCountIsCorrect(queryWithParams);\n        }\n\n        return this.sqliteBasics.all(db, queryWithParams);\n    }\n\n    /**\n     * Converts RxDB queries to SQL for better performance.\n     * Returns fallback info if query is too complex for SQL conversion.\n     */\n    private convertRxQueryToSQL(\n        query: any\n    ): { canUseSql: true; sql: string; params: any[] } | { canUseSql: false } {\n        try {\n            let sqlParts: string[] = [`SELECT data FROM \"${this.tableName}\"`];\n            let whereClauses: string[] = [];\n            let params: any[] = [];\n            let orderBy: string[] = [];\n\n            const selector = query.selector || {};\n\n            // Let RxDB handle deleted document filtering at the application level\n            // Only add deleted filter if the query explicitly requests it\n\n            // Convert selector to SQL WHERE clauses\n            const selectorResult = this.convertSelectorToSQL(selector, params);\n            if (!selectorResult.canConvert) {\n                return { canUseSql: false };\n            }\n            whereClauses.push(...selectorResult.clauses);\n\n            // Handle sorting\n            if (query.sort) {\n                const sortResult = this.convertSortToSQL(query.sort);\n                if (!sortResult.canConvert) {\n                    return { canUseSql: false };\n                }\n                orderBy.push(...sortResult.clauses);\n            }\n\n            // Build the final SQL\n            if (whereClauses.length > 0) {\n                sqlParts.push(`WHERE ${whereClauses.join(' AND ')}`);\n            }\n\n            if (orderBy.length > 0) {\n                sqlParts.push(`ORDER BY ${orderBy.join(', ')}`);\n            }\n\n            // Handle limit and skip\n            if (query.limit !== undefined) {\n                sqlParts.push(`LIMIT ?`);\n                params.push(query.limit);\n            }\n\n            if (query.skip !== undefined && query.skip > 0) {\n                sqlParts.push(`OFFSET ?`);\n                params.push(query.skip);\n            }\n\n            const sql = sqlParts.join(' ');\n\n            return {\n                canUseSql: true,\n                sql,\n                params,\n            };\n        } catch (error) {\n            // If anything goes wrong, fallback to JS\n            return { canUseSql: false };\n        }\n    }\n\n    private convertSelectorToSQL(\n        selector: any,\n        params: any[]\n    ): { canConvert: boolean; clauses: string[] } {\n        const clauses: string[] = [];\n\n        for (const [field, value] of Object.entries(selector)) {\n            if (field === '_deleted') {\n                // Handle deleted field - RxDB uses boolean, SQLite uses integer\n                if (\n                    typeof value === 'object' &&\n                    value !== null &&\n                    '$eq' in value\n                ) {\n                    clauses.push('deleted = ?');\n                    params.push((value as any).$eq ? 1 : 0);\n                } else {\n                    clauses.push('deleted = ?');\n                    params.push(value ? 1 : 0);\n                }\n            } else if (\n                field === '_meta' &&\n                typeof value === 'object' &&\n                value !== null\n            ) {\n                // Handle _meta.lwt queries\n                const metaResult = this.convertMetaFieldToSQL(\n                    value as any,\n                    params\n                );\n                if (!metaResult.canConvert) {\n                    return { canConvert: false, clauses: [] };\n                }\n                clauses.push(...metaResult.clauses);\n            } else if (field === '$or') {\n                // Handle $or queries\n                const orResult = this.convertOrToSQL(value as any[], params);\n                if (!orResult.canConvert) {\n                    return { canConvert: false, clauses: [] };\n                }\n                clauses.push(orResult.clause);\n            } else if (field === '$and') {\n                // Handle $and queries\n                const andResult = this.convertAndToSQL(value as any[], params);\n                if (!andResult.canConvert) {\n                    return { canConvert: false, clauses: [] };\n                }\n                clauses.push(...andResult.clauses);\n            } else {\n                // Handle regular document fields\n                const fieldResult = this.convertFieldToSQL(\n                    field,\n                    value,\n                    params\n                );\n                if (!fieldResult.canConvert) {\n                    return { canConvert: false, clauses: [] };\n                }\n                clauses.push(fieldResult.clause);\n            }\n        }\n\n        return { canConvert: true, clauses };\n    }\n\n    private convertMetaFieldToSQL(\n        metaValue: any,\n        params: any[]\n    ): { canConvert: boolean; clauses: string[] } {\n        const clauses: string[] = [];\n\n        if (metaValue.lwt !== undefined) {\n            if (typeof metaValue.lwt === 'object') {\n                // Handle operators like $gt, $lt, etc.\n                for (const [op, opValue] of Object.entries(metaValue.lwt)) {\n                    switch (op) {\n                        case '$gt':\n                            clauses.push('lastWriteTime > ?');\n                            params.push(opValue);\n                            break;\n                        case '$gte':\n                            clauses.push('lastWriteTime >= ?');\n                            params.push(opValue);\n                            break;\n                        case '$lt':\n                            clauses.push('lastWriteTime < ?');\n                            params.push(opValue);\n                            break;\n                        case '$lte':\n                            clauses.push('lastWriteTime <= ?');\n                            params.push(opValue);\n                            break;\n                        case '$eq':\n                            clauses.push('lastWriteTime = ?');\n                            params.push(opValue);\n                            break;\n                        default:\n                            return { canConvert: false, clauses: [] };\n                    }\n                }\n            } else {\n                clauses.push('lastWriteTime = ?');\n                params.push(metaValue.lwt);\n            }\n        }\n\n        return { canConvert: true, clauses };\n    }\n\n    private convertOrToSQL(\n        orConditions: any[],\n        params: any[]\n    ): { canConvert: boolean; clause: string } {\n        const orClauses: string[] = [];\n\n        for (const condition of orConditions) {\n            // Don't let sub-conditions handle _deleted - we handle it at the top level\n            const cleanCondition = { ...condition };\n            delete cleanCondition._deleted;\n\n            const conditionResult = this.convertSelectorToSQL(\n                cleanCondition,\n                params\n            );\n            if (!conditionResult.canConvert) {\n                return { canConvert: false, clause: '' };\n            }\n            if (conditionResult.clauses.length > 0) {\n                orClauses.push(`(${conditionResult.clauses.join(' AND ')})`);\n            } else {\n                // If a condition produces no clauses, it means \"match all\"\n                // For OR, if any sub-condition matches all, the whole OR matches all\n                orClauses.push('1=1');\n            }\n        }\n\n        if (orClauses.length === 0) {\n            return { canConvert: false, clause: '' };\n        }\n\n        return { canConvert: true, clause: `(${orClauses.join(' OR ')})` };\n    }\n\n    private convertAndToSQL(\n        andConditions: any[],\n        params: any[]\n    ): { canConvert: boolean; clauses: string[] } {\n        const andClauses: string[] = [];\n\n        for (const condition of andConditions) {\n            const conditionResult = this.convertSelectorToSQL(\n                condition,\n                params\n            );\n            if (!conditionResult.canConvert) {\n                return { canConvert: false, clauses: [] };\n            }\n            andClauses.push(...conditionResult.clauses);\n        }\n\n        return { canConvert: true, clauses: andClauses };\n    }\n\n    private convertFieldToSQL(\n        field: string,\n        value: any,\n        params: any[]\n    ): { canConvert: boolean; clause: string } {\n        const isPrimaryKey = field === this.primaryPath;\n        const jsonPath = isPrimaryKey ? '$.id' : `$.${field}`;\n\n        if (value === null) {\n            if (isPrimaryKey) {\n                return {\n                    canConvert: true,\n                    clause: `id IS NULL`,\n                };\n            } else {\n                return {\n                    canConvert: true,\n                    clause: `json_extract(data, '${jsonPath}') IS NULL`,\n                };\n            }\n        }\n\n        if (typeof value === 'object' && value !== null) {\n            // Handle operators\n            if (value.hasOwnProperty('$exists')) {\n                if (value.$exists === false) {\n                    return {\n                        canConvert: true,\n                        clause: `json_extract(data, '${jsonPath}') IS NULL`,\n                    };\n                } else if (value.$exists === true) {\n                    return {\n                        canConvert: true,\n                        clause: `json_extract(data, '${jsonPath}') IS NOT NULL`,\n                    };\n                }\n            }\n\n            if (value.hasOwnProperty('$eq')) {\n                const sqlValue = this.convertValueForSQL(value.$eq);\n                params.push(sqlValue);\n                return {\n                    canConvert: true,\n                    clause: isPrimaryKey\n                        ? `id = ?`\n                        : `json_extract(data, '${jsonPath}') = ?`,\n                };\n            }\n\n            if (value.hasOwnProperty('$ne')) {\n                const sqlValue = this.convertValueForSQL(value.$ne);\n                params.push(sqlValue);\n                if (isPrimaryKey) {\n                    return {\n                        canConvert: true,\n                        clause: `id != ?`,\n                    };\n                } else {\n                    // For JSON fields, $ne should also match NULL values (missing fields)\n                    // because in MongoDB/RxDB, missing fields are considered different from any value\n                    return {\n                        canConvert: true,\n                        clause: `(json_extract(data, '${jsonPath}') != ? OR json_extract(data, '${jsonPath}') IS NULL)`,\n                    };\n                }\n            }\n\n            if (value.hasOwnProperty('$in')) {\n                const inValues = value.$in;\n                if (!Array.isArray(inValues) || inValues.length === 0) {\n                    return { canConvert: false, clause: '' };\n                }\n                const placeholders = inValues.map(() => '?').join(',');\n                const sqlValues = inValues.map((v) =>\n                    this.convertValueForSQL(v)\n                );\n                params.push(...sqlValues);\n                return {\n                    canConvert: true,\n                    clause: isPrimaryKey\n                        ? `id IN (${placeholders})`\n                        : `json_extract(data, '${jsonPath}') IN (${placeholders})`,\n                };\n            }\n\n            if (value.hasOwnProperty('$nin')) {\n                const ninValues = value.$nin;\n                if (!Array.isArray(ninValues) || ninValues.length === 0) {\n                    return { canConvert: false, clause: '' };\n                }\n                const placeholders = ninValues.map(() => '?').join(',');\n                const sqlValues = ninValues.map((v) =>\n                    this.convertValueForSQL(v)\n                );\n                params.push(...sqlValues);\n                return {\n                    canConvert: true,\n                    clause: isPrimaryKey\n                        ? `id NOT IN (${placeholders})`\n                        : `json_extract(data, '${jsonPath}') NOT IN (${placeholders})`,\n                };\n            }\n\n            // Comparison operators\n            for (const [op, opValue] of Object.entries(value)) {\n                switch (op) {\n                    case '$gt':\n                        params.push(this.convertValueForSQL(opValue));\n                        return {\n                            canConvert: true,\n                            clause: isPrimaryKey\n                                ? `id > ?`\n                                : this.getJsonComparisonClause(\n                                      jsonPath,\n                                      '>',\n                                      typeof opValue === 'number'\n                                  ),\n                        };\n                    case '$gte':\n                        params.push(this.convertValueForSQL(opValue));\n                        return {\n                            canConvert: true,\n                            clause: isPrimaryKey\n                                ? `id >= ?`\n                                : this.getJsonComparisonClause(\n                                      jsonPath,\n                                      '>=',\n                                      typeof opValue === 'number'\n                                  ),\n                        };\n                    case '$lt':\n                        params.push(this.convertValueForSQL(opValue));\n                        return {\n                            canConvert: true,\n                            clause: isPrimaryKey\n                                ? `id < ?`\n                                : this.getJsonComparisonClause(\n                                      jsonPath,\n                                      '<',\n                                      typeof opValue === 'number'\n                                  ),\n                        };\n                    case '$lte':\n                        params.push(this.convertValueForSQL(opValue));\n                        return {\n                            canConvert: true,\n                            clause: isPrimaryKey\n                                ? `id <= ?`\n                                : this.getJsonComparisonClause(\n                                      jsonPath,\n                                      '<=',\n                                      typeof opValue === 'number'\n                                  ),\n                        };\n                    case '$regex':\n                        // SQLite doesn't have native regex, fall back to JS\n                        return { canConvert: false, clause: '' };\n                    default:\n                        // Unsupported operator, fall back to JS\n                        return { canConvert: false, clause: '' };\n                }\n            }\n\n            // Complex object, fall back to JS\n            return { canConvert: false, clause: '' };\n        }\n\n        // Simple equality\n        const sqlValue = this.convertValueForSQL(value);\n        params.push(sqlValue);\n        return {\n            canConvert: true,\n            clause: isPrimaryKey\n                ? `id = ?`\n                : `json_extract(data, '${jsonPath}') = ?`,\n        };\n    }\n\n    private convertSortToSQL(sort: any[]): {\n        canConvert: boolean;\n        clauses: string[];\n    } {\n        const clauses: string[] = [];\n\n        for (const sortItem of sort) {\n            const field = Object.keys(sortItem)[0];\n            const direction = sortItem[field] === 'desc' ? 'DESC' : 'ASC';\n\n            if (field === '_meta.lwt') {\n                clauses.push(`lastWriteTime ${direction}`);\n            } else if (field === this.primaryPath) {\n                clauses.push(`id ${direction}`);\n            } else {\n                // Sort by JSON field\n                const jsonPath = `$.${field}`;\n                clauses.push(`json_extract(data, '${jsonPath}') ${direction}`);\n            }\n        }\n\n        return { canConvert: true, clauses };\n    }\n\n    private convertValueForSQL(value: any): any {\n        if (typeof value === 'boolean') {\n            return value ? 1 : 0;\n        }\n        return value;\n    }\n\n    private getJsonComparisonClause(\n        jsonPath: string,\n        operator: string,\n        isNumeric: boolean\n    ): string {\n        if (isNumeric) {\n            // For numeric comparisons, cast to REAL to ensure proper numeric comparison\n            return `CAST(json_extract(data, '${jsonPath}') AS REAL) ${operator} ?`;\n        } else {\n            // For text comparisons, use regular json_extract\n            return `json_extract(data, '${jsonPath}') ${operator} ?`;\n        }\n    }\n\n    /**\n     * @link https://medium.com/@JasonWyatt/squeezing-performance-from-sqlite-insertions-971aff98eef2\n     */\n    async bulkWrite(\n        documentWrites: BulkWriteRow<RxDocType>[],\n        context: string\n    ): Promise<RxStorageBulkWriteResponse<RxDocType>> {\n        this.openWriteCount$.next(this.openWriteCount$.getValue() + 1);\n        const database = await this.internals.databasePromise;\n        const ret: RxStorageBulkWriteResponse<RxDocType> = {\n            error: [],\n        };\n        const writePromises: Promise<any>[] = [];\n        let categorized: CategorizeBulkWriteRowsOutput<RxDocType> = {} as any;\n\n        await sqliteTransaction(\n            database,\n            this.sqliteBasics,\n            async () => {\n                if (this.closed) {\n                    this.openWriteCount$.next(\n                        this.openWriteCount$.getValue() - 1\n                    );\n                    throw new Error(\n                        'SQLite.bulkWrite(' +\n                            context +\n                            ') already closed ' +\n                            this.tableName +\n                            ' context: ' +\n                            context\n                    );\n                }\n                // Extract IDs from the documents being written\n                const idsToQuery = documentWrites.map(\n                    (row) => row.document[this.primaryPath] as string\n                );\n\n                const docsInDb: Map<\n                    RxDocumentData<RxDocType>[StringKeys<RxDocType>],\n                    RxDocumentData<RxDocType>\n                > = new Map();\n\n                // Only query the specific documents we're writing, not everything\n                if (idsToQuery.length > 0) {\n                    const placeholders = idsToQuery.map(() => '?').join(',');\n                    const result = await this.all(database, {\n                        query: `SELECT data FROM \"${this.tableName}\" WHERE id IN (${placeholders})`,\n                        params: idsToQuery,\n                        context: {\n                            method: 'bulkWrite',\n                            data: documentWrites,\n                        },\n                    });\n\n                    result.forEach((docSQLResult) => {\n                        const doc = JSON.parse(\n                            getDataFromResultRow(docSQLResult)\n                        );\n                        const id = doc[this.primaryPath];\n                        docsInDb.set(id, doc);\n                    });\n                }\n                categorized = categorizeBulkWriteRows(\n                    this,\n                    this.primaryPath,\n                    docsInDb,\n                    documentWrites,\n                    context\n                );\n                ret.error = categorized.errors;\n\n                categorized.bulkInsertDocs.forEach((row) => {\n                    const insertQuery = getSQLiteInsertSQL(\n                        this.tableName,\n                        this.primaryPath as any,\n                        row.document\n                    );\n                    writePromises.push(\n                        this.all(database, {\n                            query: insertQuery.query,\n                            params: insertQuery.params,\n                            context: {\n                                method: 'bulkWrite',\n                                data: categorized,\n                            },\n                        })\n                    );\n                });\n\n                categorized.bulkUpdateDocs.forEach((row) => {\n                    const updateQuery = getSQLiteUpdateSQL<RxDocType>(\n                        this.tableName,\n                        this.primaryPath,\n                        row\n                    );\n                    writePromises.push(this.run(database, updateQuery));\n                });\n\n                await Promise.all(writePromises);\n\n                // close transaction\n                if (this.closed) {\n                    this.openWriteCount$.next(\n                        this.openWriteCount$.getValue() - 1\n                    );\n                    return 'ROLLBACK';\n                } else {\n                    this.openWriteCount$.next(\n                        this.openWriteCount$.getValue() - 1\n                    );\n                    return 'COMMIT';\n                }\n            },\n            {\n                databaseName: this.databaseName,\n                collectionName: this.collectionName,\n            }\n        );\n\n        if (categorized && categorized.eventBulk.events.length > 0) {\n            const lastState = ensureNotFalsy(categorized.newestRow).document;\n            categorized.eventBulk.checkpoint = {\n                id: lastState[this.primaryPath],\n                lwt: lastState._meta.lwt,\n            };\n            this.changes$.next(categorized.eventBulk);\n        }\n\n        return ret;\n    }\n\n    async query(\n        originalPreparedQuery: PreparedQuery<RxDocType>\n    ): Promise<RxStorageQueryResult<RxDocType>> {\n        const database = await this.internals.databasePromise;\n        const query = originalPreparedQuery.query;\n\n        // Try to convert to SQL query for better performance\n        const sqlQuery = this.convertRxQueryToSQL(query);\n\n        if (sqlQuery.canUseSql) {\n            // Use optimized SQL query\n            if (this.devMode) {\n                console.log(\n                    `ðŸ“Š SQL Optimization: Using SQL query for better performance`\n                );\n                console.log(`   SQL: ${sqlQuery.sql}`);\n                console.log(`   Params: ${JSON.stringify(sqlQuery.params)}`);\n            }\n\n            const subResult = await this.all(database, {\n                query: sqlQuery.sql,\n                params: sqlQuery.params,\n                context: {\n                    method: 'query',\n                    data: originalPreparedQuery,\n                },\n            });\n\n            const result: RxDocumentData<RxDocType>[] = [];\n            subResult.forEach((row) => {\n                const docData = JSON.parse(getDataFromResultRow(row));\n                result.push(docData);\n            });\n\n            return {\n                documents: result,\n            };\n        } else {\n            // Fallback to in-memory filtering for complex queries\n            if (this.devMode) {\n                console.log(\n                    `ðŸ”„ Fallback: Using JavaScript filtering for complex query`\n                );\n                console.log(`   Query: ${JSON.stringify(query, null, 2)}`);\n            }\n\n            const skip = query.skip ? query.skip : 0;\n            const limit = query.limit ? query.limit : Infinity;\n            const skipPlusLimit = skip + limit;\n            const queryMatcher = getQueryMatcher(this.schema, query as any);\n\n            const subResult = await this.all(database, {\n                query: 'SELECT data FROM \"' + this.tableName + '\"',\n                params: [],\n                context: {\n                    method: 'query',\n                    data: originalPreparedQuery,\n                },\n            });\n\n            let result: RxDocumentData<RxDocType>[] = [];\n            subResult.forEach((row) => {\n                const docData = JSON.parse(getDataFromResultRow(row));\n                if (queryMatcher(docData)) {\n                    result.push(docData);\n                }\n            });\n\n            const sortComparator = getSortComparator(this.schema, query as any);\n            result = result.sort(sortComparator);\n            result = result.slice(skip, skipPlusLimit);\n\n            return {\n                documents: result,\n            };\n        }\n    }\n    async count(\n        originalPreparedQuery: PreparedQuery<RxDocType>\n    ): Promise<RxStorageCountResult> {\n        const database = await this.internals.databasePromise;\n        const query = originalPreparedQuery.query;\n\n        // Try to use SQL COUNT for better performance\n        const sqlQuery = this.convertRxQueryToSQL(query);\n\n        if (sqlQuery.canUseSql) {\n            // Convert SELECT to COUNT query\n            const countSql = sqlQuery.sql.replace(\n                `SELECT data FROM \"${this.tableName}\"`,\n                `SELECT COUNT(*) as count FROM \"${this.tableName}\"`\n            );\n\n            // Remove LIMIT and OFFSET for count (they don't affect count)\n            const cleanCountSql = countSql\n                .replace(/\\s+LIMIT\\s+\\?/gi, '')\n                .replace(/\\s+OFFSET\\s+\\?/gi, '');\n\n            // Remove corresponding LIMIT/OFFSET parameters\n            let countParams = [...sqlQuery.params];\n            if (query.limit !== undefined) {\n                countParams.pop(); // Remove limit param\n            }\n            if (query.skip !== undefined && query.skip > 0) {\n                countParams.pop(); // Remove offset param\n            }\n\n            if (this.devMode) {\n                console.log(`ðŸ“Š SQL Count: Using optimized COUNT query`);\n                console.log(`   SQL: ${cleanCountSql}`);\n                console.log(`   Params: ${JSON.stringify(countParams)}`);\n            }\n\n            const result = await this.all(database, {\n                query: cleanCountSql,\n                params: countParams,\n                context: {\n                    method: 'count',\n                    data: originalPreparedQuery,\n                },\n            });\n\n            // Extract count from the result row\n            const countValue = Array.isArray(result[0])\n                ? result[0][0]\n                : (result[0] as any).count;\n\n            return {\n                count: countValue || 0,\n                mode: 'fast',\n            };\n        } else {\n            // Fallback to full query and count in memory\n            const results = await this.query(originalPreparedQuery);\n            return {\n                count: results.documents.length,\n                mode: 'fast',\n            };\n        }\n    }\n\n    async findDocumentsById(\n        ids: string[],\n        withDeleted: boolean\n    ): Promise<RxDocumentData<RxDocType>[]> {\n        const database = await this.internals.databasePromise;\n\n        if (this.closed) {\n            throw new Error(\n                'SQLite.findDocumentsById() already closed ' +\n                    this.tableName +\n                    ' context: findDocumentsById'\n            );\n        }\n\n        if (ids.length === 0) {\n            return [];\n        }\n\n        // Create placeholders for the IN clause\n        const placeholders = ids.map(() => '?').join(',');\n        let query = `SELECT data FROM \"${this.tableName}\" WHERE id IN (${placeholders})`;\n        let params = [...ids];\n\n        // Filter out deleted documents unless explicitly requested\n        if (!withDeleted) {\n            query += ' AND deleted = 0';\n        }\n\n        const result = await this.all(database, {\n            query,\n            params,\n            context: {\n                method: 'findDocumentsById',\n                data: ids,\n            },\n        });\n\n        const ret: RxDocumentData<RxDocType>[] = [];\n        for (let i = 0; i < result.length; ++i) {\n            const resultRow = result[i];\n            const doc: RxDocumentData<RxDocType> = JSON.parse(\n                getDataFromResultRow(resultRow)\n            );\n            ret.push(doc);\n        }\n        return ret;\n    }\n\n    changeStream(): Observable<\n        EventBulk<\n            RxStorageChangeEvent<RxDocumentData<RxDocType>>,\n            RxStorageDefaultCheckpoint\n        >\n    > {\n        return this.changes$.asObservable();\n    }\n\n    async cleanup(minimumDeletedTime: number): Promise<boolean> {\n        await promiseWait(0);\n        await promiseWait(0);\n        const database = await this.internals.databasePromise;\n\n        /**\n         * Purge deleted documents\n         */\n        const minTimestamp = new Date().getTime() - minimumDeletedTime;\n        await this.all(database, {\n            query: `\n                    DELETE FROM\n                        \"${this.tableName}\"\n                    WHERE\n                        deleted = 1\n                        AND\n                        lastWriteTime < ?\n                `,\n            params: [minTimestamp],\n            context: {\n                method: 'cleanup',\n                data: minimumDeletedTime,\n            },\n        });\n        return true;\n    }\n\n    async getAttachmentData(\n        _documentId: string,\n        _attachmentId: string\n    ): Promise<string> {\n        throw newRxError('SQL1');\n    }\n\n    async remove(): Promise<void> {\n        if (this.closed) {\n            throw new Error('closed already');\n        }\n        const database = await this.internals.databasePromise;\n        const promises = [\n            this.run(database, {\n                query: `DROP TABLE IF EXISTS \"${this.tableName}\"`,\n                params: [],\n                context: {\n                    method: 'remove',\n                    data: this.tableName,\n                },\n            }),\n        ];\n        await Promise.all(promises);\n        return this.close();\n    }\n\n    async close(): Promise<void> {\n        const queue = TX_QUEUE_BY_DATABASE.get(\n            await this.internals.databasePromise\n        );\n        if (queue) {\n            await queue;\n        }\n\n        if (this.closed) {\n            return this.closed;\n        }\n        this.closed = (async () => {\n            await firstValueFrom(\n                this.openWriteCount$.pipe(filter((v) => v === 0))\n            );\n            const database = await this.internals.databasePromise;\n\n            /**\n             * First get a transaction\n             * to ensure currently running operations\n             * are finished\n             */\n            await sqliteTransaction(database, this.sqliteBasics, () => {\n                return Promise.resolve('COMMIT');\n            }).catch(() => {});\n            this.changes$.complete();\n            await closeDatabaseConnection(\n                this.databaseName,\n                this.storage.settings.sqliteBasics\n            );\n        })();\n        return this.closed;\n    }\n}\n\nexport async function createSQLiteTrialStorageInstance<RxDocType>(\n    storage: RxStorageSQLiteProd,\n    params: RxStorageInstanceCreationParams<\n        RxDocType,\n        SQLiteInstanceCreationOptions\n    >,\n    settings: SQLiteStorageSettings\n): Promise<RxStorageInstanceSQLite<RxDocType>> {\n    const sqliteBasics = settings.sqliteBasics;\n    const tableName = params.collectionName + '-' + params.schema.version;\n\n    if (params.schema.attachments) {\n        throw newRxError('SQL1');\n    }\n\n    const internals: Partial<SQLiteInternals> = {};\n    const useDatabaseName =\n        (settings.databaseNamePrefix ? settings.databaseNamePrefix : '') +\n        params.databaseName;\n    internals.databasePromise = getDatabaseConnection(\n        storage.settings.sqliteBasics,\n        useDatabaseName\n    ).then(async (database) => {\n        await sqliteTransaction(\n            database,\n            sqliteBasics,\n            async () => {\n                // Create the main table\n                const tableQuery = `\n                CREATE TABLE IF NOT EXISTS \"${tableName}\"(\n                    id TEXT NOT NULL PRIMARY KEY UNIQUE,\n                    revision TEXT,\n                    deleted BOOLEAN NOT NULL CHECK (deleted IN (0, 1)),\n                    lastWriteTime INTEGER NOT NULL,\n                    data json\n                );\n                `;\n                await sqliteBasics.run(database, {\n                    query: tableQuery,\n                    params: [],\n                    context: {\n                        method: 'createSQLiteStorageInstance create tables',\n                        data: params.databaseName,\n                    },\n                });\n\n                // Create performance indexes - only on universal RxDB metadata fields\n                const indexes = [\n                    // Core RxDB metadata indexes that every collection has\n                    `CREATE INDEX IF NOT EXISTS \"idx_${tableName}_deleted\" ON \"${tableName}\" (deleted);`,\n                    `CREATE INDEX IF NOT EXISTS \"idx_${tableName}_lwt\" ON \"${tableName}\" (lastWriteTime);`,\n                    `CREATE INDEX IF NOT EXISTS \"idx_${tableName}_deleted_lwt\" ON \"${tableName}\" (deleted, lastWriteTime);`,\n\n                    // Note: Additional application-specific indexes should be created by the application\n                    // using the schema.indexes property in RxDB, not hardcoded in the storage layer.\n                    // The SQL query optimization engine will dynamically handle any field names.\n                ];\n\n                for (const indexQuery of indexes) {\n                    await sqliteBasics.run(database, {\n                        query: indexQuery,\n                        params: [],\n                        context: {\n                            method: 'createSQLiteStorageInstance create indexes',\n                            data: params.databaseName,\n                        },\n                    });\n                }\n\n                return 'COMMIT';\n            },\n            {\n                indexCreation: false,\n                databaseName: params.databaseName,\n                collectionName: params.collectionName,\n            }\n        );\n        return database;\n    });\n\n    const instance = new RxStorageInstanceSQLite(\n        storage,\n        params.databaseName,\n        params.collectionName,\n        params.schema,\n        internals as any,\n        params.options,\n        settings,\n        tableName,\n        params.devMode\n    );\n\n    await addRxStorageMultiInstanceSupport(\n        RX_STORAGE_NAME_SQLITE,\n        params,\n        instance\n    );\n\n    return instance;\n}\n"],"mappings":"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","ignoreList":[]}