{"version":3,"file":"sqlite-storage-instance.js","names":["getPrimaryFieldOfPrimaryKey","categorizeBulkWriteRows","ensureNotFalsy","addRxStorageMultiInstanceSupport","promiseWait","getQueryMatcher","BehaviorSubject","Subject","filter","firstValueFrom","closeDatabaseConnection","ensureParamsCountIsCorrect","getDatabaseConnection","getSQLiteUpdateSQL","RX_STORAGE_NAME_SQLITE","sqliteTransaction","getDataFromResultRow","getSQLiteInsertSQL","TX_QUEUE_BY_DATABASE","getSortComparator","newRxError","instanceId","RxStorageInstanceSQLite","storage","databaseName","collectionName","schema","internals","options","settings","tableName","devMode","changes$","openWriteCount$","sqliteBasics","primaryPath","primaryKey","_proto","prototype","run","db","queryWithParams","all","convertRxQueryToSQL","query","sqlParts","whereClauses","params","orderBy","selector","selectorResult","convertSelectorToSQL","canConvert","canUseSql","push","clauses","sort","sortResult","convertSortToSQL","length","join","limit","undefined","skip","sql","error","field","value","Object","entries","$eq","metaResult","convertMetaFieldToSQL","orResult","convertOrToSQL","clause","andResult","convertAndToSQL","fieldResult","convertFieldToSQL","metaValue","lwt","op","opValue","orConditions","orClauses","condition","cleanCondition","_deleted","conditionResult","andConditions","andClauses","isPrimaryKey","jsonPath","hasOwnProperty","$exists","sqlValue","convertValueForSQL","$ne","inValues","$in","Array","isArray","placeholders","map","sqlValues","v","ninValues","$nin","getJsonComparisonClause","sortItem","keys","direction","operator","isNumeric","bulkWrite","documentWrites","context","next","getValue","database","databasePromise","ret","writePromises","categorized","closed","Error","idsToQuery","row","document","docsInDb","Map","result","method","data","forEach","docSQLResult","doc","JSON","parse","id","set","errors","bulkInsertDocs","insertQuery","bulkUpdateDocs","updateQuery","Promise","eventBulk","events","lastState","newestRow","checkpoint","_meta","originalPreparedQuery","sqlQuery","console","log","stringify","subResult","docData","documents","Infinity","skipPlusLimit","queryMatcher","sortComparator","slice","count","countSql","replace","cleanCountSql","countParams","pop","countValue","mode","results","findDocumentsById","ids","withDeleted","i","resultRow","changeStream","asObservable","cleanup","minimumDeletedTime","minTimestamp","Date","getTime","getAttachmentData","_documentId","_attachmentId","remove","promises","close","queue","get","pipe","resolve","catch","complete","createSQLiteTrialStorageInstance","version","attachments","useDatabaseName","databaseNamePrefix","then","tableQuery","indexes","indexQuery","indexCreation","instance"],"sources":["../../../../src/plugins/storage-sqlite-prod/sqlite-storage-instance.ts"],"sourcesContent":["import {\n    RxJsonSchema,\n    RxStorageInstanceCreationParams,\n    RxStorageInstance,\n    getPrimaryFieldOfPrimaryKey,\n    EventBulk,\n    RxStorageChangeEvent,\n    RxDocumentData,\n    BulkWriteRow,\n    RxStorageBulkWriteResponse,\n    RxStorageQueryResult,\n    categorizeBulkWriteRows,\n    ensureNotFalsy,\n    StringKeys,\n    addRxStorageMultiInstanceSupport,\n    RxStorageDefaultCheckpoint,\n    CategorizeBulkWriteRowsOutput,\n    RxStorageCountResult,\n    promiseWait,\n    getQueryMatcher,\n    PreparedQuery,\n} from '../../index.ts';\nimport {\n    BehaviorSubject,\n    Observable,\n    Subject,\n    filter,\n    firstValueFrom,\n} from 'rxjs';\nimport type { RxStorageSQLiteProd } from './index.ts';\nimport {\n    closeDatabaseConnection,\n    ensureParamsCountIsCorrect,\n    getDatabaseConnection,\n    getSQLiteUpdateSQL,\n    RX_STORAGE_NAME_SQLITE,\n    sqliteTransaction,\n    getDataFromResultRow,\n    getSQLiteInsertSQL,\n    TX_QUEUE_BY_DATABASE,\n} from './sqlite-helpers.ts';\nimport type {\n    SQLiteBasics,\n    SQLiteInstanceCreationOptions,\n    SQLiteInternals,\n    SQLiteQueryWithParams,\n    SQLiteStorageSettings,\n} from './sqlite-types.ts';\nimport { getSortComparator } from '../../rx-query-helper.ts';\nimport { newRxError } from '../../rx-error.ts';\n\nlet instanceId = 0;\nexport class RxStorageInstanceSQLite<RxDocType>\n    implements\n        RxStorageInstance<\n            RxDocType,\n            SQLiteInternals,\n            SQLiteInstanceCreationOptions,\n            RxStorageDefaultCheckpoint\n        >\n{\n    public readonly primaryPath: StringKeys<RxDocType>;\n    private changes$: Subject<\n        EventBulk<\n            RxStorageChangeEvent<RxDocumentData<RxDocType>>,\n            RxStorageDefaultCheckpoint\n        >\n    > = new Subject();\n    public readonly instanceId = instanceId++;\n    public closed?: Promise<void>;\n\n    public sqliteBasics: SQLiteBasics<any>;\n\n    public readonly openWriteCount$ = new BehaviorSubject(0);\n\n    constructor(\n        public readonly storage: RxStorageSQLiteProd,\n        public readonly databaseName: string,\n        public readonly collectionName: string,\n        public readonly schema: Readonly<\n            RxJsonSchema<RxDocumentData<RxDocType>>\n        >,\n        public readonly internals: SQLiteInternals,\n        public readonly options: Readonly<SQLiteInstanceCreationOptions>,\n        public readonly settings: SQLiteStorageSettings,\n        public readonly tableName: string,\n        public readonly devMode: boolean\n    ) {\n        this.sqliteBasics = storage.settings.sqliteBasics;\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(\n            this.schema.primaryKey\n        ) as any;\n    }\n\n    run(db: any, queryWithParams: SQLiteQueryWithParams) {\n        if (this.devMode) {\n            ensureParamsCountIsCorrect(queryWithParams);\n        }\n        return this.sqliteBasics.run(db, queryWithParams);\n    }\n    all(db: any, queryWithParams: SQLiteQueryWithParams) {\n        if (this.devMode) {\n            ensureParamsCountIsCorrect(queryWithParams);\n        }\n\n        return this.sqliteBasics.all(db, queryWithParams);\n    }\n\n    /**\n     * Converts RxDB queries to SQL for better performance.\n     * Returns fallback info if query is too complex for SQL conversion.\n     */\n    private convertRxQueryToSQL(\n        query: any\n    ): { canUseSql: true; sql: string; params: any[] } | { canUseSql: false } {\n        try {\n            let sqlParts: string[] = [`SELECT data FROM \"${this.tableName}\"`];\n            let whereClauses: string[] = [];\n            let params: any[] = [];\n            let orderBy: string[] = [];\n\n            const selector = query.selector || {};\n\n            // Let RxDB handle deleted document filtering at the application level\n            // Only add deleted filter if the query explicitly requests it\n\n            // Convert selector to SQL WHERE clauses\n            const selectorResult = this.convertSelectorToSQL(selector, params);\n            if (!selectorResult.canConvert) {\n                return { canUseSql: false };\n            }\n            whereClauses.push(...selectorResult.clauses);\n\n            // Handle sorting\n            if (query.sort) {\n                const sortResult = this.convertSortToSQL(query.sort);\n                if (!sortResult.canConvert) {\n                    return { canUseSql: false };\n                }\n                orderBy.push(...sortResult.clauses);\n            }\n\n            // Build the final SQL\n            if (whereClauses.length > 0) {\n                sqlParts.push(`WHERE ${whereClauses.join(' AND ')}`);\n            }\n\n            if (orderBy.length > 0) {\n                sqlParts.push(`ORDER BY ${orderBy.join(', ')}`);\n            }\n\n            // Handle limit and skip\n            if (query.limit !== undefined) {\n                sqlParts.push(`LIMIT ?`);\n                params.push(query.limit);\n            }\n\n            if (query.skip !== undefined && query.skip > 0) {\n                sqlParts.push(`OFFSET ?`);\n                params.push(query.skip);\n            }\n\n            const sql = sqlParts.join(' ');\n\n            return {\n                canUseSql: true,\n                sql,\n                params,\n            };\n        } catch (error) {\n            // If anything goes wrong, fallback to JS\n            return { canUseSql: false };\n        }\n    }\n\n    private convertSelectorToSQL(\n        selector: any,\n        params: any[]\n    ): { canConvert: boolean; clauses: string[] } {\n        const clauses: string[] = [];\n\n        for (const [field, value] of Object.entries(selector)) {\n            if (field === '_deleted') {\n                // Handle deleted field - RxDB uses boolean, SQLite uses integer\n                if (\n                    typeof value === 'object' &&\n                    value !== null &&\n                    '$eq' in value\n                ) {\n                    clauses.push('deleted = ?');\n                    params.push((value as any).$eq ? 1 : 0);\n                } else {\n                    clauses.push('deleted = ?');\n                    params.push(value ? 1 : 0);\n                }\n            } else if (\n                field === '_meta' &&\n                typeof value === 'object' &&\n                value !== null\n            ) {\n                // Handle _meta.lwt queries\n                const metaResult = this.convertMetaFieldToSQL(\n                    value as any,\n                    params\n                );\n                if (!metaResult.canConvert) {\n                    return { canConvert: false, clauses: [] };\n                }\n                clauses.push(...metaResult.clauses);\n            } else if (field === '$or') {\n                // Handle $or queries\n                const orResult = this.convertOrToSQL(value as any[], params);\n                if (!orResult.canConvert) {\n                    return { canConvert: false, clauses: [] };\n                }\n                clauses.push(orResult.clause);\n            } else if (field === '$and') {\n                // Handle $and queries\n                const andResult = this.convertAndToSQL(value as any[], params);\n                if (!andResult.canConvert) {\n                    return { canConvert: false, clauses: [] };\n                }\n                clauses.push(...andResult.clauses);\n            } else {\n                // Handle regular document fields\n                const fieldResult = this.convertFieldToSQL(\n                    field,\n                    value,\n                    params\n                );\n                if (!fieldResult.canConvert) {\n                    return { canConvert: false, clauses: [] };\n                }\n                clauses.push(fieldResult.clause);\n            }\n        }\n\n        return { canConvert: true, clauses };\n    }\n\n    private convertMetaFieldToSQL(\n        metaValue: any,\n        params: any[]\n    ): { canConvert: boolean; clauses: string[] } {\n        const clauses: string[] = [];\n\n        if (metaValue.lwt !== undefined) {\n            if (typeof metaValue.lwt === 'object') {\n                // Handle operators like $gt, $lt, etc.\n                for (const [op, opValue] of Object.entries(metaValue.lwt)) {\n                    switch (op) {\n                        case '$gt':\n                            clauses.push('lastWriteTime > ?');\n                            params.push(opValue);\n                            break;\n                        case '$gte':\n                            clauses.push('lastWriteTime >= ?');\n                            params.push(opValue);\n                            break;\n                        case '$lt':\n                            clauses.push('lastWriteTime < ?');\n                            params.push(opValue);\n                            break;\n                        case '$lte':\n                            clauses.push('lastWriteTime <= ?');\n                            params.push(opValue);\n                            break;\n                        case '$eq':\n                            clauses.push('lastWriteTime = ?');\n                            params.push(opValue);\n                            break;\n                        default:\n                            return { canConvert: false, clauses: [] };\n                    }\n                }\n            } else {\n                clauses.push('lastWriteTime = ?');\n                params.push(metaValue.lwt);\n            }\n        }\n\n        return { canConvert: true, clauses };\n    }\n\n    private convertOrToSQL(\n        orConditions: any[],\n        params: any[]\n    ): { canConvert: boolean; clause: string } {\n        const orClauses: string[] = [];\n\n        for (const condition of orConditions) {\n            // Don't let sub-conditions handle _deleted - we handle it at the top level\n            const cleanCondition = { ...condition };\n            delete cleanCondition._deleted;\n\n            const conditionResult = this.convertSelectorToSQL(\n                cleanCondition,\n                params\n            );\n            if (!conditionResult.canConvert) {\n                return { canConvert: false, clause: '' };\n            }\n            if (conditionResult.clauses.length > 0) {\n                orClauses.push(`(${conditionResult.clauses.join(' AND ')})`);\n            } else {\n                // If a condition produces no clauses, it means \"match all\"\n                // For OR, if any sub-condition matches all, the whole OR matches all\n                orClauses.push('1=1');\n            }\n        }\n\n        if (orClauses.length === 0) {\n            return { canConvert: false, clause: '' };\n        }\n\n        return { canConvert: true, clause: `(${orClauses.join(' OR ')})` };\n    }\n\n    private convertAndToSQL(\n        andConditions: any[],\n        params: any[]\n    ): { canConvert: boolean; clauses: string[] } {\n        const andClauses: string[] = [];\n\n        for (const condition of andConditions) {\n            const conditionResult = this.convertSelectorToSQL(\n                condition,\n                params\n            );\n            if (!conditionResult.canConvert) {\n                return { canConvert: false, clauses: [] };\n            }\n            andClauses.push(...conditionResult.clauses);\n        }\n\n        return { canConvert: true, clauses: andClauses };\n    }\n\n    private convertFieldToSQL(\n        field: string,\n        value: any,\n        params: any[]\n    ): { canConvert: boolean; clause: string } {\n        const isPrimaryKey = field === this.primaryPath;\n        const jsonPath = isPrimaryKey ? '$.id' : `$.${field}`;\n\n        if (value === null) {\n            if (isPrimaryKey) {\n                return {\n                    canConvert: true,\n                    clause: `id IS NULL`,\n                };\n            } else {\n                return {\n                    canConvert: true,\n                    clause: `json_extract(data, '${jsonPath}') IS NULL`,\n                };\n            }\n        }\n\n        if (typeof value === 'object' && value !== null) {\n            // Handle operators\n            if (value.hasOwnProperty('$exists')) {\n                if (value.$exists === false) {\n                    return {\n                        canConvert: true,\n                        clause: `json_extract(data, '${jsonPath}') IS NULL`,\n                    };\n                } else if (value.$exists === true) {\n                    return {\n                        canConvert: true,\n                        clause: `json_extract(data, '${jsonPath}') IS NOT NULL`,\n                    };\n                }\n            }\n\n            if (value.hasOwnProperty('$eq')) {\n                const sqlValue = this.convertValueForSQL(value.$eq);\n                params.push(sqlValue);\n                return {\n                    canConvert: true,\n                    clause: isPrimaryKey\n                        ? `id = ?`\n                        : `json_extract(data, '${jsonPath}') = ?`,\n                };\n            }\n\n            if (value.hasOwnProperty('$ne')) {\n                const sqlValue = this.convertValueForSQL(value.$ne);\n                params.push(sqlValue);\n                if (isPrimaryKey) {\n                    return {\n                        canConvert: true,\n                        clause: `id != ?`,\n                    };\n                } else {\n                    // For JSON fields, $ne should also match NULL values (missing fields)\n                    // because in MongoDB/RxDB, missing fields are considered different from any value\n                    return {\n                        canConvert: true,\n                        clause: `(json_extract(data, '${jsonPath}') != ? OR json_extract(data, '${jsonPath}') IS NULL)`,\n                    };\n                }\n            }\n\n            if (value.hasOwnProperty('$in')) {\n                const inValues = value.$in;\n                if (!Array.isArray(inValues) || inValues.length === 0) {\n                    return { canConvert: false, clause: '' };\n                }\n                const placeholders = inValues.map(() => '?').join(',');\n                const sqlValues = inValues.map((v) =>\n                    this.convertValueForSQL(v)\n                );\n                params.push(...sqlValues);\n                return {\n                    canConvert: true,\n                    clause: isPrimaryKey\n                        ? `id IN (${placeholders})`\n                        : `json_extract(data, '${jsonPath}') IN (${placeholders})`,\n                };\n            }\n\n            if (value.hasOwnProperty('$nin')) {\n                const ninValues = value.$nin;\n                if (!Array.isArray(ninValues) || ninValues.length === 0) {\n                    return { canConvert: false, clause: '' };\n                }\n                const placeholders = ninValues.map(() => '?').join(',');\n                const sqlValues = ninValues.map((v) =>\n                    this.convertValueForSQL(v)\n                );\n                params.push(...sqlValues);\n                return {\n                    canConvert: true,\n                    clause: isPrimaryKey\n                        ? `id NOT IN (${placeholders})`\n                        : `json_extract(data, '${jsonPath}') NOT IN (${placeholders})`,\n                };\n            }\n\n            // Comparison operators\n            for (const [op, opValue] of Object.entries(value)) {\n                switch (op) {\n                    case '$gt':\n                        params.push(this.convertValueForSQL(opValue));\n                        return {\n                            canConvert: true,\n                            clause: isPrimaryKey\n                                ? `id > ?`\n                                : this.getJsonComparisonClause(\n                                      jsonPath,\n                                      '>',\n                                      typeof opValue === 'number'\n                                  ),\n                        };\n                    case '$gte':\n                        params.push(this.convertValueForSQL(opValue));\n                        return {\n                            canConvert: true,\n                            clause: isPrimaryKey\n                                ? `id >= ?`\n                                : this.getJsonComparisonClause(\n                                      jsonPath,\n                                      '>=',\n                                      typeof opValue === 'number'\n                                  ),\n                        };\n                    case '$lt':\n                        params.push(this.convertValueForSQL(opValue));\n                        return {\n                            canConvert: true,\n                            clause: isPrimaryKey\n                                ? `id < ?`\n                                : this.getJsonComparisonClause(\n                                      jsonPath,\n                                      '<',\n                                      typeof opValue === 'number'\n                                  ),\n                        };\n                    case '$lte':\n                        params.push(this.convertValueForSQL(opValue));\n                        return {\n                            canConvert: true,\n                            clause: isPrimaryKey\n                                ? `id <= ?`\n                                : this.getJsonComparisonClause(\n                                      jsonPath,\n                                      '<=',\n                                      typeof opValue === 'number'\n                                  ),\n                        };\n                    case '$regex':\n                        // SQLite doesn't have native regex, fall back to JS\n                        return { canConvert: false, clause: '' };\n                    default:\n                        // Unsupported operator, fall back to JS\n                        return { canConvert: false, clause: '' };\n                }\n            }\n\n            // Complex object, fall back to JS\n            return { canConvert: false, clause: '' };\n        }\n\n        // Simple equality\n        const sqlValue = this.convertValueForSQL(value);\n        params.push(sqlValue);\n        return {\n            canConvert: true,\n            clause: isPrimaryKey\n                ? `id = ?`\n                : `json_extract(data, '${jsonPath}') = ?`,\n        };\n    }\n\n    private convertSortToSQL(sort: any[]): {\n        canConvert: boolean;\n        clauses: string[];\n    } {\n        const clauses: string[] = [];\n\n        for (const sortItem of sort) {\n            const field = Object.keys(sortItem)[0];\n            const direction = sortItem[field] === 'desc' ? 'DESC' : 'ASC';\n\n            if (field === '_meta.lwt') {\n                clauses.push(`lastWriteTime ${direction}`);\n            } else if (field === this.primaryPath) {\n                clauses.push(`id ${direction}`);\n            } else {\n                // Sort by JSON field\n                const jsonPath = `$.${field}`;\n                clauses.push(`json_extract(data, '${jsonPath}') ${direction}`);\n            }\n        }\n\n        return { canConvert: true, clauses };\n    }\n\n    private convertValueForSQL(value: any): any {\n        if (typeof value === 'boolean') {\n            return value ? 1 : 0;\n        }\n        return value;\n    }\n\n    private getJsonComparisonClause(\n        jsonPath: string,\n        operator: string,\n        isNumeric: boolean\n    ): string {\n        if (isNumeric) {\n            // For numeric comparisons, cast to REAL to ensure proper numeric comparison\n            return `CAST(json_extract(data, '${jsonPath}') AS REAL) ${operator} ?`;\n        } else {\n            // For text comparisons, use regular json_extract\n            return `json_extract(data, '${jsonPath}') ${operator} ?`;\n        }\n    }\n\n    /**\n     * @link https://medium.com/@JasonWyatt/squeezing-performance-from-sqlite-insertions-971aff98eef2\n     */\n    async bulkWrite(\n        documentWrites: BulkWriteRow<RxDocType>[],\n        context: string\n    ): Promise<RxStorageBulkWriteResponse<RxDocType>> {\n        this.openWriteCount$.next(this.openWriteCount$.getValue() + 1);\n        const database = await this.internals.databasePromise;\n        const ret: RxStorageBulkWriteResponse<RxDocType> = {\n            error: [],\n        };\n        const writePromises: Promise<any>[] = [];\n        let categorized: CategorizeBulkWriteRowsOutput<RxDocType> = {} as any;\n\n        await sqliteTransaction(\n            database,\n            this.sqliteBasics,\n            async () => {\n                if (this.closed) {\n                    this.openWriteCount$.next(\n                        this.openWriteCount$.getValue() - 1\n                    );\n                    throw new Error(\n                        'SQLite.bulkWrite(' +\n                            context +\n                            ') already closed ' +\n                            this.tableName +\n                            ' context: ' +\n                            context\n                    );\n                }\n                // Extract IDs from the documents being written\n                const idsToQuery = documentWrites.map(\n                    (row) => row.document[this.primaryPath] as string\n                );\n\n                const docsInDb: Map<\n                    RxDocumentData<RxDocType>[StringKeys<RxDocType>],\n                    RxDocumentData<RxDocType>\n                > = new Map();\n\n                // Only query the specific documents we're writing, not everything\n                if (idsToQuery.length > 0) {\n                    const placeholders = idsToQuery.map(() => '?').join(',');\n                    const result = await this.all(database, {\n                        query: `SELECT data FROM \"${this.tableName}\" WHERE id IN (${placeholders})`,\n                        params: idsToQuery,\n                        context: {\n                            method: 'bulkWrite',\n                            data: documentWrites,\n                        },\n                    });\n\n                    result.forEach((docSQLResult) => {\n                        const doc = JSON.parse(\n                            getDataFromResultRow(docSQLResult)\n                        );\n                        const id = doc[this.primaryPath];\n                        docsInDb.set(id, doc);\n                    });\n                }\n                categorized = categorizeBulkWriteRows(\n                    this,\n                    this.primaryPath,\n                    docsInDb,\n                    documentWrites,\n                    context\n                );\n                ret.error = categorized.errors;\n\n                categorized.bulkInsertDocs.forEach((row) => {\n                    const insertQuery = getSQLiteInsertSQL(\n                        this.tableName,\n                        this.primaryPath as any,\n                        row.document\n                    );\n                    writePromises.push(\n                        this.all(database, {\n                            query: insertQuery.query,\n                            params: insertQuery.params,\n                            context: {\n                                method: 'bulkWrite',\n                                data: categorized,\n                            },\n                        })\n                    );\n                });\n\n                categorized.bulkUpdateDocs.forEach((row) => {\n                    const updateQuery = getSQLiteUpdateSQL<RxDocType>(\n                        this.tableName,\n                        this.primaryPath,\n                        row\n                    );\n                    writePromises.push(this.run(database, updateQuery));\n                });\n\n                await Promise.all(writePromises);\n\n                // close transaction\n                if (this.closed) {\n                    this.openWriteCount$.next(\n                        this.openWriteCount$.getValue() - 1\n                    );\n                    return 'ROLLBACK';\n                } else {\n                    this.openWriteCount$.next(\n                        this.openWriteCount$.getValue() - 1\n                    );\n                    return 'COMMIT';\n                }\n            },\n            {\n                databaseName: this.databaseName,\n                collectionName: this.collectionName,\n            }\n        );\n\n        if (categorized && categorized.eventBulk.events.length > 0) {\n            const lastState = ensureNotFalsy(categorized.newestRow).document;\n            categorized.eventBulk.checkpoint = {\n                id: lastState[this.primaryPath],\n                lwt: lastState._meta.lwt,\n            };\n            this.changes$.next(categorized.eventBulk);\n        }\n\n        return ret;\n    }\n\n    async query(\n        originalPreparedQuery: PreparedQuery<RxDocType>\n    ): Promise<RxStorageQueryResult<RxDocType>> {\n        const database = await this.internals.databasePromise;\n        const query = originalPreparedQuery.query;\n\n        // Try to convert to SQL query for better performance\n        const sqlQuery = this.convertRxQueryToSQL(query);\n\n        if (sqlQuery.canUseSql) {\n            // Use optimized SQL query\n            if (this.devMode) {\n                console.log(\n                    `📊 SQL Optimization: Using SQL query for better performance`\n                );\n                console.log(`   SQL: ${sqlQuery.sql}`);\n                console.log(`   Params: ${JSON.stringify(sqlQuery.params)}`);\n            }\n\n            const subResult = await this.all(database, {\n                query: sqlQuery.sql,\n                params: sqlQuery.params,\n                context: {\n                    method: 'query',\n                    data: originalPreparedQuery,\n                },\n            });\n\n            const result: RxDocumentData<RxDocType>[] = [];\n            subResult.forEach((row) => {\n                const docData = JSON.parse(getDataFromResultRow(row));\n                result.push(docData);\n            });\n\n            return {\n                documents: result,\n            };\n        } else {\n            // Fallback to in-memory filtering for complex queries\n            if (this.devMode) {\n                console.log(\n                    `🔄 Fallback: Using JavaScript filtering for complex query`\n                );\n                console.log(`   Query: ${JSON.stringify(query, null, 2)}`);\n            }\n\n            const skip = query.skip ? query.skip : 0;\n            const limit = query.limit ? query.limit : Infinity;\n            const skipPlusLimit = skip + limit;\n            const queryMatcher = getQueryMatcher(this.schema, query as any);\n\n            const subResult = await this.all(database, {\n                query: 'SELECT data FROM \"' + this.tableName + '\"',\n                params: [],\n                context: {\n                    method: 'query',\n                    data: originalPreparedQuery,\n                },\n            });\n\n            let result: RxDocumentData<RxDocType>[] = [];\n            subResult.forEach((row) => {\n                const docData = JSON.parse(getDataFromResultRow(row));\n                if (queryMatcher(docData)) {\n                    result.push(docData);\n                }\n            });\n\n            const sortComparator = getSortComparator(this.schema, query as any);\n            result = result.sort(sortComparator);\n            result = result.slice(skip, skipPlusLimit);\n\n            return {\n                documents: result,\n            };\n        }\n    }\n    async count(\n        originalPreparedQuery: PreparedQuery<RxDocType>\n    ): Promise<RxStorageCountResult> {\n        const database = await this.internals.databasePromise;\n        const query = originalPreparedQuery.query;\n\n        // Try to use SQL COUNT for better performance\n        const sqlQuery = this.convertRxQueryToSQL(query);\n\n        if (sqlQuery.canUseSql) {\n            // Convert SELECT to COUNT query\n            const countSql = sqlQuery.sql.replace(\n                `SELECT data FROM \"${this.tableName}\"`,\n                `SELECT COUNT(*) as count FROM \"${this.tableName}\"`\n            );\n\n            // Remove LIMIT and OFFSET for count (they don't affect count)\n            const cleanCountSql = countSql\n                .replace(/\\s+LIMIT\\s+\\?/gi, '')\n                .replace(/\\s+OFFSET\\s+\\?/gi, '');\n\n            // Remove corresponding LIMIT/OFFSET parameters\n            let countParams = [...sqlQuery.params];\n            if (query.limit !== undefined) {\n                countParams.pop(); // Remove limit param\n            }\n            if (query.skip !== undefined && query.skip > 0) {\n                countParams.pop(); // Remove offset param\n            }\n\n            if (this.devMode) {\n                console.log(`📊 SQL Count: Using optimized COUNT query`);\n                console.log(`   SQL: ${cleanCountSql}`);\n                console.log(`   Params: ${JSON.stringify(countParams)}`);\n            }\n\n            const result = await this.all(database, {\n                query: cleanCountSql,\n                params: countParams,\n                context: {\n                    method: 'count',\n                    data: originalPreparedQuery,\n                },\n            });\n\n            // Extract count from the result row\n            const countValue = Array.isArray(result[0])\n                ? result[0][0]\n                : (result[0] as any).count;\n\n            return {\n                count: countValue || 0,\n                mode: 'fast',\n            };\n        } else {\n            // Fallback to full query and count in memory\n            const results = await this.query(originalPreparedQuery);\n            return {\n                count: results.documents.length,\n                mode: 'fast',\n            };\n        }\n    }\n\n    async findDocumentsById(\n        ids: string[],\n        withDeleted: boolean\n    ): Promise<RxDocumentData<RxDocType>[]> {\n        const database = await this.internals.databasePromise;\n\n        if (this.closed) {\n            throw new Error(\n                'SQLite.findDocumentsById() already closed ' +\n                    this.tableName +\n                    ' context: findDocumentsById'\n            );\n        }\n\n        if (ids.length === 0) {\n            return [];\n        }\n\n        // Create placeholders for the IN clause\n        const placeholders = ids.map(() => '?').join(',');\n        let query = `SELECT data FROM \"${this.tableName}\" WHERE id IN (${placeholders})`;\n        let params = [...ids];\n\n        // Filter out deleted documents unless explicitly requested\n        if (!withDeleted) {\n            query += ' AND deleted = 0';\n        }\n\n        const result = await this.all(database, {\n            query,\n            params,\n            context: {\n                method: 'findDocumentsById',\n                data: ids,\n            },\n        });\n\n        const ret: RxDocumentData<RxDocType>[] = [];\n        for (let i = 0; i < result.length; ++i) {\n            const resultRow = result[i];\n            const doc: RxDocumentData<RxDocType> = JSON.parse(\n                getDataFromResultRow(resultRow)\n            );\n            ret.push(doc);\n        }\n        return ret;\n    }\n\n    changeStream(): Observable<\n        EventBulk<\n            RxStorageChangeEvent<RxDocumentData<RxDocType>>,\n            RxStorageDefaultCheckpoint\n        >\n    > {\n        return this.changes$.asObservable();\n    }\n\n    async cleanup(minimumDeletedTime: number): Promise<boolean> {\n        await promiseWait(0);\n        await promiseWait(0);\n        const database = await this.internals.databasePromise;\n\n        /**\n         * Purge deleted documents\n         */\n        const minTimestamp = new Date().getTime() - minimumDeletedTime;\n        await this.all(database, {\n            query: `\n                    DELETE FROM\n                        \"${this.tableName}\"\n                    WHERE\n                        deleted = 1\n                        AND\n                        lastWriteTime < ?\n                `,\n            params: [minTimestamp],\n            context: {\n                method: 'cleanup',\n                data: minimumDeletedTime,\n            },\n        });\n        return true;\n    }\n\n    async getAttachmentData(\n        _documentId: string,\n        _attachmentId: string\n    ): Promise<string> {\n        throw newRxError('SQL1');\n    }\n\n    async remove(): Promise<void> {\n        if (this.closed) {\n            throw new Error('closed already');\n        }\n        const database = await this.internals.databasePromise;\n        const promises = [\n            this.run(database, {\n                query: `DROP TABLE IF EXISTS \"${this.tableName}\"`,\n                params: [],\n                context: {\n                    method: 'remove',\n                    data: this.tableName,\n                },\n            }),\n        ];\n        await Promise.all(promises);\n        return this.close();\n    }\n\n    async close(): Promise<void> {\n        const queue = TX_QUEUE_BY_DATABASE.get(\n            await this.internals.databasePromise\n        );\n        if (queue) {\n            await queue;\n        }\n\n        if (this.closed) {\n            return this.closed;\n        }\n        this.closed = (async () => {\n            await firstValueFrom(\n                this.openWriteCount$.pipe(filter((v) => v === 0))\n            );\n            const database = await this.internals.databasePromise;\n\n            /**\n             * First get a transaction\n             * to ensure currently running operations\n             * are finished\n             */\n            await sqliteTransaction(database, this.sqliteBasics, () => {\n                return Promise.resolve('COMMIT');\n            }).catch(() => {});\n            this.changes$.complete();\n            await closeDatabaseConnection(\n                this.databaseName,\n                this.storage.settings.sqliteBasics\n            );\n        })();\n        return this.closed;\n    }\n}\n\nexport async function createSQLiteTrialStorageInstance<RxDocType>(\n    storage: RxStorageSQLiteProd,\n    params: RxStorageInstanceCreationParams<\n        RxDocType,\n        SQLiteInstanceCreationOptions\n    >,\n    settings: SQLiteStorageSettings\n): Promise<RxStorageInstanceSQLite<RxDocType>> {\n    const sqliteBasics = settings.sqliteBasics;\n    const tableName = params.collectionName + '-' + params.schema.version;\n\n    if (params.schema.attachments) {\n        throw newRxError('SQL1');\n    }\n\n    const internals: Partial<SQLiteInternals> = {};\n    const useDatabaseName =\n        (settings.databaseNamePrefix ? settings.databaseNamePrefix : '') +\n        params.databaseName;\n    internals.databasePromise = getDatabaseConnection(\n        storage.settings.sqliteBasics,\n        useDatabaseName\n    ).then(async (database) => {\n        await sqliteTransaction(\n            database,\n            sqliteBasics,\n            async () => {\n                // Create the main table\n                const tableQuery = `\n                CREATE TABLE IF NOT EXISTS \"${tableName}\"(\n                    id TEXT NOT NULL PRIMARY KEY UNIQUE,\n                    revision TEXT,\n                    deleted BOOLEAN NOT NULL CHECK (deleted IN (0, 1)),\n                    lastWriteTime INTEGER NOT NULL,\n                    data json\n                );\n                `;\n                await sqliteBasics.run(database, {\n                    query: tableQuery,\n                    params: [],\n                    context: {\n                        method: 'createSQLiteStorageInstance create tables',\n                        data: params.databaseName,\n                    },\n                });\n\n                // Create performance indexes - only on universal RxDB metadata fields\n                const indexes = [\n                    // Core RxDB metadata indexes that every collection has\n                    `CREATE INDEX IF NOT EXISTS \"idx_${tableName}_deleted\" ON \"${tableName}\" (deleted);`,\n                    `CREATE INDEX IF NOT EXISTS \"idx_${tableName}_lwt\" ON \"${tableName}\" (lastWriteTime);`,\n                    `CREATE INDEX IF NOT EXISTS \"idx_${tableName}_deleted_lwt\" ON \"${tableName}\" (deleted, lastWriteTime);`,\n\n                    // Note: Additional application-specific indexes should be created by the application\n                    // using the schema.indexes property in RxDB, not hardcoded in the storage layer.\n                    // The SQL query optimization engine will dynamically handle any field names.\n                ];\n\n                for (const indexQuery of indexes) {\n                    await sqliteBasics.run(database, {\n                        query: indexQuery,\n                        params: [],\n                        context: {\n                            method: 'createSQLiteStorageInstance create indexes',\n                            data: params.databaseName,\n                        },\n                    });\n                }\n\n                return 'COMMIT';\n            },\n            {\n                indexCreation: false,\n                databaseName: params.databaseName,\n                collectionName: params.collectionName,\n            }\n        );\n        return database;\n    });\n\n    const instance = new RxStorageInstanceSQLite(\n        storage,\n        params.databaseName,\n        params.collectionName,\n        params.schema,\n        internals as any,\n        params.options,\n        settings,\n        tableName,\n        params.devMode\n    );\n\n    await addRxStorageMultiInstanceSupport(\n        RX_STORAGE_NAME_SQLITE,\n        params,\n        instance\n    );\n\n    return instance;\n}\n"],"mappings":"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","ignoreList":[]}